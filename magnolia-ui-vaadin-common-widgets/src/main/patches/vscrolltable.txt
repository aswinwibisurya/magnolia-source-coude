diff -uwr k1/src/main/java/com/vaadin/terminal/gwt/client/ui/VScrollTable.java k2/src/main/java/com/vaadin/terminal/gwt/client/ui/VScrollTable.java
--- k1/src/main/java/com/vaadin/terminal/gwt/client/ui/VScrollTable.java	2012-11-06 13:18:07.000000000 +0200
+++ k2/src/main/java/com/vaadin/terminal/gwt/client/ui/VScrollTable.java	2012-11-07 14:06:42.000000000 +0200
@@ -82,7 +82,7 @@
 import com.vaadin.terminal.gwt.client.Util;
 import com.vaadin.terminal.gwt.client.VConsole;
 import com.vaadin.terminal.gwt.client.VTooltip;
-import com.vaadin.terminal.gwt.client.ui.VScrollTable.VScrollTableBody.VScrollTableRow;
+import com.vaadin.terminal.gwt.client.ui.VScrollTablePatched.VScrollTableBody.VScrollTableRow;
 import com.vaadin.terminal.gwt.client.ui.dd.DDUtil;
 import com.vaadin.terminal.gwt.client.ui.dd.VAbstractDropHandler;
 import com.vaadin.terminal.gwt.client.ui.dd.VAcceptCallback;
@@ -115,9 +115,21 @@
  * 
  * TODO implement unregistering for child components in Cells
  */
-public class VScrollTable extends FlowPanel implements Table, ScrollHandler,
+public class VScrollTablePatched extends FlowPanel implements Table, ScrollHandler,
         VHasDropHandler, FocusHandler, BlurHandler, Focusable, ActionOwner {
 
+    protected TableHead createTableHead() {
+        return new TableHead();
+    }
+    
+    protected HeaderCell createHeaderCell(String colId, String headerText) {
+        return new HeaderCell(colId, headerText);
+    }
+    
+    protected VScrollTableDropHandler createScrollTableDropHandler() {
+        return new VScrollTableDropHandler();
+    }
+    
     public static final String ATTRIBUTE_PAGEBUFFER_FIRST = "pb-ft";
     public static final String ATTRIBUTE_PAGEBUFFER_LAST = "pb-l";
 
@@ -185,7 +197,7 @@
 
     private int selectMode = Table.SELECT_MODE_NONE;
 
-    private final HashSet<String> selectedRowKeys = new HashSet<String>();
+    protected final HashSet<String> selectedRowKeys = new HashSet<String>();
 
     /*
      * When scrolling and selecting at the same time, the selections are not in
@@ -209,7 +221,7 @@
     /*
      * Helper to store selection range start in when using the keyboard
      */
-    private VScrollTableRow selectionRangeStart;
+    protected VScrollTableRow selectionRangeStart;
 
     /*
      * Flag for notifying when the selection has changed and should be sent to
@@ -325,7 +337,7 @@
      */
     private boolean headerChangedDuringUpdate = false;
 
-    protected final TableHead tHead = new TableHead();
+    protected final TableHead tHead = createTableHead();
 
     private final TableFooter tFoot = new TableFooter();
 
@@ -424,7 +436,7 @@
     private Set<String> collapsedColumns;
 
     private final RowRequestHandler rowRequestHandler;
-    private VScrollTableBody scrollBody;
+    protected VScrollTableBody scrollBody;
     private int firstvisible = 0;
     private boolean sortAscending;
     private String sortColumn;
@@ -460,7 +472,7 @@
     private boolean hasFocus = false;
     private int dragmode;
 
-    private int multiselectmode;
+    protected int multiselectmode;
     private int tabIndex;
     private TouchScrollDelegate touchScrollDelegate;
 
@@ -499,7 +511,7 @@
 
     ContextMenuDetails contextMenu;
 
-    public VScrollTable() {
+    public VScrollTablePatched() {
         setMultiSelectMode(MULTISELECT_MODE_DEFAULT);
 
         scrollBodyPanel.addStyleName(CLASSNAME + "-body-wrapper");
@@ -963,7 +975,7 @@
             }
         } else {
             if (dropHandler == null) {
-                dropHandler = new VScrollTableDropHandler();
+                dropHandler = createScrollTableDropHandler();
             }
             dropHandler.updateAcceptRules(ac);
         }
@@ -1667,7 +1679,7 @@
                 && multiselectmode == MULTISELECT_MODE_DEFAULT;
     }
 
-    private void setMultiSelectMode(int multiselectmode) {
+    protected void setMultiSelectMode(int multiselectmode) {
         if (BrowserInfo.get().isTouchDevice()) {
             // Always use the simple mode for touch devices that do not have
             // shift/ctrl keys
@@ -2334,7 +2346,7 @@
 
         Element td = DOM.createTD();
 
-        Element captionContainer = DOM.createDiv();
+        protected Element captionContainer = DOM.createDiv();
 
         Element sortIndicator = DOM.createDiv();
 
@@ -2552,7 +2564,7 @@
                     handleCaptionEvent(event);
                     boolean stopPropagation = true;
                     if (event.getTypeInt() == Event.ONCONTEXTMENU
-                            && !client.hasEventListeners(VScrollTable.this,
+                            && !client.hasEventListeners(VScrollTablePatched.this,
                                     HEADER_CLICK_EVENT_ID)) {
                         // Prevent showing the browser's context menu only when
                         // there is a header click listener.
@@ -2605,7 +2617,7 @@
          *            The click event
          */
         private void fireHeaderClickedEvent(Event event) {
-            if (client.hasEventListeners(VScrollTable.this,
+            if (client.hasEventListeners(VScrollTablePatched.this,
                     HEADER_CLICK_EVENT_ID)) {
                 MouseEventDetails details = new MouseEventDetails(event);
                 client.updateVariable(paintableId, "headerClickEvent",
@@ -2927,7 +2939,7 @@
 
         HashMap<String, HeaderCell> availableCells = new HashMap<String, HeaderCell>();
 
-        Element div = DOM.createDiv();
+        protected Element div = DOM.createDiv();
         Element hTableWrapper = DOM.createDiv();
         Element hTableContainer = DOM.createDiv();
         Element table = DOM.createTable();
@@ -3023,7 +3035,7 @@
                 String caption = buildCaptionHtmlSnippet(col);
                 HeaderCell c = getHeaderCell(cid);
                 if (c == null) {
-                    c = new HeaderCell(cid, caption);
+                    c = createHeaderCell(cid, caption);
                     availableCells.put(cid, c);
                     if (initializedAndAttached) {
                         // we will need a column width recalculation
@@ -3292,7 +3304,7 @@
             private VScrollTableRow currentlyFocusedRow;
 
             public VisibleColumnAction(String colKey) {
-                super(VScrollTable.TableHead.this);
+                super(VScrollTablePatched.TableHead.this);
                 this.colKey = colKey;
                 caption = tHead.getHeaderCell(colKey).getCaption();
                 currentlyFocusedRow = focusedRow;
@@ -3645,7 +3657,7 @@
                 }
                 boolean stopPropagation = true;
                 if (event.getTypeInt() == Event.ONCONTEXTMENU
-                        && !client.hasEventListeners(VScrollTable.this,
+                        && !client.hasEventListeners(VScrollTablePatched.this,
                                 FOOTER_CLICK_EVENT_ID)) {
                     // Show browser context menu if a footer click listener is
                     // not present
@@ -3679,7 +3691,7 @@
          *            The click event
          */
         private void fireFooterClickedEvent(Event event) {
-            if (client.hasEventListeners(VScrollTable.this,
+            if (client.hasEventListeners(VScrollTablePatched.this,
                     FOOTER_CLICK_EVENT_ID)) {
                 MouseEventDetails details = new MouseEventDetails(event);
                 client.updateVariable(paintableId, "footerClickEvent",
@@ -4047,11 +4059,19 @@
      */
     public class VScrollTableBody extends Panel {
 
+        protected VScrollTableRow createScrollTableRow(UIDL uidl, char[] aligns) {
+            return new VScrollTableRow(uidl, aligns);
+        }
+             
+        protected VScrollTableRow createScrollTableRow() {
+            return new VScrollTableRow();
+        }
+
         public static final int DEFAULT_ROW_HEIGHT = 24;
 
         private double rowHeight = -1;
 
-        private final LinkedList<Widget> renderedRows = new LinkedList<Widget>();
+        public final LinkedList<Widget> renderedRows = new LinkedList<Widget>();
 
         /**
          * Due some optimizations row height measuring is deferred and initial
@@ -4326,7 +4346,7 @@
                 // This is a generated row.
                 return new VScrollTableGeneratedRow(uidl, aligns2);
             }
-            return new VScrollTableRow(uidl, aligns2);
+            return createScrollTableRow(uidl, aligns2);
         }
 
         private void addRowBeforeFirstRendered(VScrollTableRow row) {
@@ -4446,12 +4466,12 @@
             final VScrollTableRow toBeRemoved = (VScrollTableRow) renderedRows
                     .get(index);
             // Unregister row tooltip
-            client.registerTooltip(VScrollTable.this, toBeRemoved.getElement(),
+            client.registerTooltip(VScrollTablePatched.this, toBeRemoved.getElement(),
                     null);
             for (int i = 0; i < toBeRemoved.getElement().getChildCount(); i++) {
                 // Unregister cell tooltips
                 Element td = toBeRemoved.getElement().getChild(i).cast();
-                client.registerTooltip(VScrollTable.this, td, null);
+                client.registerTooltip(VScrollTablePatched.this, td, null);
             }
             lazyUnregistryBag.add(toBeRemoved);
             tBodyElement.removeChild(toBeRemoved.getElement());
@@ -4524,7 +4544,7 @@
                         rowHeight = lastKnownRowHeight;
                     } else if (isAttached()) {
                         // measure row height by adding a dummy row
-                        VScrollTableRow scrollTableRow = new VScrollTableRow();
+                        VScrollTableRow scrollTableRow = createScrollTableRow();
                         tBodyElement.appendChild(scrollTableRow.getElement());
                         getRowHeight(forceUpdate);
                         tBodyElement.removeChild(scrollTableRow.getElement());
@@ -4604,14 +4624,14 @@
             NodeList<TableRowElement> rows = tBodyElement.getRows();
             if (rows.getLength() == 0) {
                 /* need to temporary add empty row and detect */
-                VScrollTableRow scrollTableRow = new VScrollTableRow();
+                VScrollTableRow scrollTableRow = createScrollTableRow();
                 tBodyElement.appendChild(scrollTableRow.getElement());
                 detectExtrawidth();
                 tBodyElement.removeChild(scrollTableRow.getElement());
             } else {
                 boolean noCells = false;
                 TableRowElement item = rows.getItem(0);
-                TableCellElement firstTD = item.getCells().getItem(0);
+                TableCellElement firstTD = item.getCells().getItem(1);
                 if (firstTD == null) {
                     // content is currently empty, we need to add a fake cell
                     // for measuring
@@ -4687,7 +4707,7 @@
             private List<UIDL> pendingComponentPaints;
 
             private String[] actionKeys = null;
-            private final TableRowElement rowElement;
+            protected final TableRowElement rowElement;
             private int index;
             private Event touchStart;
             private static final String ROW_CLASSNAME_EVEN = CLASSNAME + "-row";
@@ -4726,10 +4746,10 @@
                 String rowDescription = uidl.getStringAttribute("rowdescr");
                 if (rowDescription != null && !rowDescription.equals("")) {
                     TooltipInfo info = new TooltipInfo(rowDescription);
-                    client.registerTooltip(VScrollTable.this, rowElement, info);
+                    client.registerTooltip(VScrollTablePatched.this, rowElement, info);
                 } else {
                     // Remove possibly previously set tooltip
-                    client.registerTooltip(VScrollTable.this, rowElement, null);
+                    client.registerTooltip(VScrollTablePatched.this, rowElement, null);
                 }
 
                 tHead.getColumnAlignments();
@@ -4767,7 +4787,7 @@
             protected void initCellWidths() {
                 final int cells = tHead.getVisibleCellCount();
                 for (int i = 0; i < cells; i++) {
-                    int w = VScrollTable.this.getColWidth(getColKeyByIndex(i));
+                    int w = VScrollTablePatched.this.getColWidth(getColKeyByIndex(i));
                     if (w < 0) {
                         w = 0;
                     }
@@ -4964,10 +4984,10 @@
 
                 if (description != null && !description.equals("")) {
                     TooltipInfo info = new TooltipInfo(description);
-                    client.registerTooltip(VScrollTable.this, td, info);
+                    client.registerTooltip(VScrollTablePatched.this, td, info);
                 } else {
                     // Remove possibly previously set tooltip
-                    client.registerTooltip(VScrollTable.this, td, null);
+                    client.registerTooltip(VScrollTablePatched.this, td, null);
                 }
 
                 td.appendChild(container);
@@ -5046,7 +5066,7 @@
              */
             private boolean handleClickEvent(Event event, Element targetTdOrTr,
                     boolean immediate) {
-                if (!client.hasEventListeners(VScrollTable.this,
+                if (!client.hasEventListeners(VScrollTablePatched.this,
                         ITEM_CLICK_EVENT_ID)) {
                     // Don't send an event if nobody is listening
                     return false;
@@ -5061,7 +5081,7 @@
                     int childIndex = DOM.getChildIndex(getElement(),
                             targetTdOrTr);
                     String colKey = null;
-                    colKey = tHead.getHeaderCell(childIndex).getColKey();
+                    colKey = tHead.getHeaderCell(childIndex - 1).getColKey();
                     client.updateVariable(paintableId, "clickedColKey", colKey,
                             false);
                 }
@@ -5090,22 +5110,22 @@
 
                     if (!containsWidget) {
                         // Only text nodes has tooltips
-                        if (client.getTooltipTitleInfo(VScrollTable.this,
+                        if (client.getTooltipTitleInfo(VScrollTablePatched.this,
                                 target) != null) {
                             // Cell has description, use it
-                            client.handleTooltipEvent(event, VScrollTable.this,
+                            client.handleTooltipEvent(event, VScrollTablePatched.this,
                                     target);
                         } else {
                             // Cell might have row description, use row
                             // description
-                            client.handleTooltipEvent(event, VScrollTable.this,
+                            client.handleTooltipEvent(event, VScrollTablePatched.this,
                                     target.getParentElement());
                         }
                     }
 
                 } else {
                     // Table row (tr)
-                    client.handleTooltipEvent(event, VScrollTable.this, target);
+                    client.handleTooltipEvent(event, VScrollTablePatched.this, target);
                 }
             }
 
@@ -5234,7 +5254,7 @@
                         showContextMenu(event);
                         if (enabled
                                 && (actionKeys != null || client
-                                        .hasEventListeners(VScrollTable.this,
+                                        .hasEventListeners(VScrollTablePatched.this,
                                                 ITEM_CLICK_EVENT_ID))) {
                             /*
                              * Prevent browser context menu only if there are
@@ -5550,15 +5570,15 @@
                 return false;
             }
 
-            protected void startRowDrag(Event event, final int type,
+            private void startRowDrag(Event event, final int type,
                     Element targetTdOrTr) {
                 VTransferable transferable = new VTransferable();
-                transferable.setDragSource(VScrollTable.this);
+                transferable.setDragSource(VScrollTablePatched.this);
                 transferable.setData("itemId", "" + rowKey);
                 NodeList<TableCellElement> cells = rowElement.getCells();
-                for (int i = 0; i < cells.getLength(); i++) {
+                for (int i = 1; i < cells.getLength(); i++) {
                     if (cells.getItem(i).isOrHasChild(targetTdOrTr)) {
-                        HeaderCell headerCell = tHead.getHeaderCell(i);
+                        HeaderCell headerCell = tHead.getHeaderCell(i - 1);
                         transferable.setData("propertyId", headerCell.cid);
                         break;
                     }
@@ -6243,7 +6263,7 @@
                 int heightBefore = getOffsetHeight();
                 scrollBodyPanel.setHeight(bodyHeight + "px");
                 if (heightBefore != getOffsetHeight()) {
-                    Util.notifyParentOfSizeChange(VScrollTable.this, false);
+                    Util.notifyParentOfSizeChange(VScrollTablePatched.this, false);
                 }
             }
             scrollBody.reLayoutComponents();
@@ -6585,7 +6605,7 @@
                     element = (Element) element.getParentElement();
                 }
                 int childIndex = DOM.getChildIndex(tr, element);
-                dropDetails.colkey = tHead.getHeaderCell(childIndex)
+                dropDetails.colkey = tHead.getHeaderCell(childIndex - 1)
                         .getColKey();
                 dropDetails.dropLocation = DDUtil.getVerticalDropLocation(
                         row.getElement(), drag.getCurrentGwtEvent(), 0.2);
@@ -6686,7 +6706,7 @@
 
         @Override
         public Paintable getPaintable() {
-            return VScrollTable.this;
+            return VScrollTablePatched.this;
         }
 
         public ApplicationConnection getApplicationConnection() {
@@ -7066,7 +7086,7 @@
      * @param key
      *            The key to remove
      */
-    private void removeRowFromUnsentSelectionRanges(VScrollTableRow row) {
+    protected void removeRowFromUnsentSelectionRanges(VScrollTableRow row) {
         Collection<SelectionRange> newRanges = null;
         for (Iterator<SelectionRange> iterator = selectedRowRanges.iterator(); iterator
                 .hasNext();) {
